--test계정 생성
CREATE USER TEST IDENTIFIED BY TEST;
--권한 부여
GRANT CONNECT, RESOURCE TO TEST;

--DDL
/*
 * CREATE: 데이터베이스의 객체를 생성하는 DDL
 * 
 * CREATE 객체형태 객체명(관련 내용)
 * 
 * --테이블 형식
 * CREATE TABLE 테이블명(
 * 		컬럼명 자료형(길이) 제약조건
 * )
 * 
 * 제약조건: 테이블에 데이터를 저장하고자 할떄 지켜야 하는 규칙
 * 		NOT NULL - NULL값 허용하지 않겠다. (필수 입력사항)
 * 		UNIQUE  - 중복 값을 허용하지 않는다.
 * 		CHECK  - 지정한 입력 사항 외에는 받지 못하게 막는 조건
 *		PRIMARY KEY  - (NOT NULL+ UNIQUE)
 *			테이블 내에서 해당 행을 인식할 수 있는 고유의 값 , 테이블 내에서 단 1개
 *		FOREIGN KEY - 다른 테이블에서 지정된 값을 연결지어 참조로 가져오는 데이터에 지정하는 제약조건
 *
 */

--테이블 생성
--데이터를 저장하기 위한 객체, 2차원의 표 형태로 데이터를 담을 수 있다. 행과 컬럼으로 구성
CREATE TABLE MEMBER(
	MEMBER_NO NUMBER,		--회원번호
	MEMBER_ID VARCHAR2(20),	--회원아이디
	MEMBER_PWD VARCHAR2(20),	--회원비밀번호
	MEMBER_NAME VARCHAR2(15)	--회원이름
);
SELECT * FROM MEMBER;

--테이블의 각 컬럼에 주석달기
--COMMENT ON COLUMN 테이블명.컬럼명 IS '주석내용';
COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원아이디';
COMMENT ON COLUMN MEMBER.MEMBER_NO IS '회원 번호';
COMMENT ON COLUMN MEMBER.MEMBER_PWD IS '회원 비밀번호';
COMMENT ON COLUMN MEMBER.MEMBER_NAME IS '회원 이름';

--테이블 정보 확인
DESC MEMBER;

SELECT * FROM USER_TAB_COLUMNS 
WHERE TABLE_NAME = 'MEMBER';
--테이블 주석 조회
SELECT *
FROM USER_TAB_COMMENTS;
--컬럼 주석 조회
SELECT *
FROM USER_COL_COMMENTS;

SELECT * FROM USER_TABLES;

--제약조건(CONSTRINIS)
--테이블을 생성할 때 각 컬럼에 값을 기록하는 것에 대한 제약사항을 설정하는 조건들
--데이터 무결성 보장 : 고유한 값이라는 혹은 값이 아무런 문제가 되지 않는다는 의미

--현재 사용자 계정에 관련된 제약 조건 확인
SELECT * FROM USER_CONS_COLUMNS;

--NOT NULL
--'널 값을 허용하지 않는다', 컬럼에 반드시 값을 기록해야 하는 경우
--데이터 삽입/수정/삭제 시에 NULL값을 허용하지 않도록 컬럼 작성 시 함께 제약조건 작성(컬럼레벨 제약조건 동록)
DROP TABLE USER_NOCONS;
CREATE TABLE USER_NOCONS(
	USER_NO NUMBER,
	USER_ID VARCHAR(20),
	USER_PWD VARCHAR(30),
	USER_NAME VARCHAR(15),
	GENDER VARCHAR(3),
	PHONE VARCHAR(14),
	EMAIL VARCHAR(30)
);
SELECT * FROM USER_NOCONS;
--테이블에 값 추가
--DML : INSERT
INSERT INTO USER_NOCONS
VALUES(1,'user01', 'pass01','한예인','여','010-1233-1234','gore@naver.com');

INSERT INTO USER_NOCONS
VALUES(2,NULL,NULL,NULL,'남',NULL,NULL);

CREATE TABLE USER_NOT_NULL(
	USER_NO NUMBER NOT NULL,	--컬럼레벨제약조건
	USER_ID VARCHAR(20) NOT NULL,
	USER_PWD VARCHAR(30) NOT NULL,
	USER_NAME VARCHAR(15) NOT NULL,
	GENDER VARCHAR(3),
	PHONE VARCHAR(14),
	EMAIL VARCHAR(30)
);
SELECT * FROM USER_NOT_NULL;

INSERT INTO USER_NOT_NULL 
VALUES(1, 'useer01','pass01','한예인','여','010-2222-2222','goRe@naver.com');

INSERT INTO USER_NOT_NULL
VALUES(2,NULL,NULL,NULL,'여',NULL,NULL);

--UNIQUE 제약조건
--중복을 허용하지 않는 제약조건
--컬럼에 값을 입력/수정할 때 중복을 확인하여 중복 값이 있을 경우 값 추가/수정을 못하게 막는 제약조건
INSERT INTO USER_NOCONS
VALUES(1, 'user01','1234','홍길동','남','010-2222-3333','hong@naver.com');

SELECT * FROM USER_NOCONS;

CREATE TABLE USER_UNIQUE(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20) UNIQUE,
	USER_PWD VARCHAR2(30),
	USER_NAME VARCHAR2(15),
	GENDER CHAR(3),
	PHONE VARCHAR2(14),
	EMAIL VARCHAR2(30)
);

INSERT INTO USER_UNIQUE 
VALUES(1, 'user01','pass01','한예인','여','010-2222-2222','gore@naver.com');
INSERT INTO USER_UNIQUE 
VALUES(1, 'user01','1234','홍길동','남','010-2222-3333','hong@naver.com');

SELECT * 
FROM USER_CONSTRAINTS C1, USER_CONS_COLUMNS C2
WHERE C1.CONSTRAINT_NAME = C2.CONSTRAINT_NAME
	AND C1.TABLE_NAME = 'USER_UNIQUE';
-- U: UNIQUE
-- P: PRIMARY KEY
-- C: CHECK (NOT NULL)
-- R: FOREIGN KEY(REFERENCCE)

CREATE TABLE USER_UNIQUE2(
	USER_NO NUMBER,
	--USER_ID VARCHAR2(20) UNIQUE,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(30),
	USER_NAME VARCHAR2(15),
	GENDER CHAR(3),
	PHONE VARCHAR2(14),
	EMAIL VARCHAR2(30),
	UNIQUE(USER_ID)		--컬럼이 모두 작성된 후에 별도로 작성하는 제약조건을 테이블 레벨 제약조건이라고 한다.
);

INSERT INTO USER_UNIQUE2
VALUES(1, 'user01','pass01','한예인','여','010-2222-2222','gore@naver.com');
INSERT INTO USER_UNIQUE2 
VALUES(1, 'user01','1234','홍길동','남','010-2222-3333','hong@naver.com');

--UNIQUE 제약조건을 여러 개 컬럼에 적용
--반드시 테이블 레벨에서 제약조건을 선언
CREATE TABLE USER_UNIQUE3(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(30),
	USER_NAME VARCHAR2(15),
	UNIQUE(USER_NO,USER_ID)		--두 개 이상의 컬럶값을 중복되지 않게 설정
);
INSERT INTO USER_UNIQUE3 
VALUES(1, 'USER01','PASS01','한예인');
SELECT * FROM USER_UNIQUE3;
INSERT INTO USER_UNIQUE3
VALUES(1, 'USER02','PASS02','홍길동');
INSERT INTO USER_UNIQUE3
VALUES(2, 'USER01','PASS03','둘예인');
INSERT INTO USER_UNIQUE3
VALUES(2, 'USER02','PASS04','삼예인');

--제약조건 이름 설정
CREATE TABLE CONS_NAME(
	TEST_DATA1 NUMBER(10) CONSTRAINT NN_DATA1 NOT NULL,
	TEST_DATA2 VARCHAR2(20) CONSTRAINT UN_DATA2 UNIQUE,
	TEST_DATA3 VARCHAR2(30),
	CONSTRAINT UK_DATA3 UNIQUE(TEST_DATA3)
);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'CONS_NAME';

--CHECK 제약조건
--컬럼에 값을 기록할 때 지정한 값 이외에는 값이 기록되지 않도록 범위를 제한하는 조건
--CHECK (컬럼명 비교연산자 값)
--Ex) CHECK(GENDER IN('M','F'))

CREATE TABLE USER_CHECK(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(30),
	USER_NAME VARCHAR2(15),
	GENDER CHAR(3) CHECK (GENDER IN('남','여'))
);

INSERT INTO USER_CHECK
VALUES(1, 'USER01','PASS01','한예인','여');
INSERT INTO USER_CHECK 
VALUES(2, 'USER02','PASS02','둘예인','남자');
INSERT INTO USER_CHECK 
VALUES(2, 'USER02','PASS02','둘예인','M');

--CHECK제약조건에 부등호 사용
CREATE TABLE TEST_CHECK2(
	TEST_DATA NUMBER(10),
	CONSTRAINT CH_TEST_DATA CHECK(TEST_DATA > 0)
);

INSERT INTO TEST_CHECK2
VALUES(10);
INSERT INTO TEST_CHECK2 
VALUES(-10);

CREATE TABLE TEST_CHECK3(
	C_NAME VARCHAR2(15),
	C_PRICE NUMBER,
	C_DATE DATE,
	C_QUAL CHAR(1),
	CONSTRAINT CK_TESTCHK3_PRICE CHECK(C_PRICE BETWEEN 1 AND 9999),
	CONSTRAINT CK_TESTCHK3_DATE CHECK(C_DATE > TO_DATE('2010/01/01','YYYY/MM/DD')),
	CONSTRAINT CK_TESTCHK3_QUAL CHECK(C_QUAL >= 'A' AND C_QUAL <= 'D')
);

SELECT * FROM USER_CONSTRAINTS 
WHERE TABLE_NAME = 'TEST_CHECK3';

--제약조건 여러개 설정하기
CREATE TABLE TEST_DUAL_CONS(
	TEST_NO NUMBER(10) NOT NULL UNIQUE,
	TEST_NO2 NUMBER NOT NULL
);
SELECT * FROM USER_CONSTRAINTS 
WHERE TABLE_NAME = 'TEST_DUAL_CONS';

--PRIMARY KEY 제약조건 
--'기본키 제약조건'
--테이블 내의 데이터중에서 행을 식별하기위한 고유값을 가지는 컬럼에 NOT NULL과 UNIQUE 제약조건을 함께 걸어주는
--즉, 테이블 전체에 대한 각 데이터의 식별자 역할을 수행시키는 제약조건
--기본키로 선언된 컬럼은 값이 반드시 들어가고, 중복이 일어나면 안된다.
--기본키 제약조건은 각 테이블 마다 반드시 한개 존재해야한다.
--기본키 제약조건은 한 컬럼에 적용 할 수도 있고, 여러컬럼을 묶어 적용할수도 있다.

CREATE TABLE USER_PK_TABLE(
	USER_NO NUMBER(10) CONSTRAINT PK_USER_NO PRIMARY KEY, 	--컬럼레벨 제약조건
	USER_ID VARCHAR2(20) UNIQUE,
	USER_PWD VARCHAR2(30) NOT NULL,
	USER_NAME VARCHAR2(15) NOT NULL,
	GENDER VARCHAR2(3) CHECK(GENDER IN ('M','F'))
);

SELECT * FROM USER_PK_TABLE;
INSERT INTO USER_PK_TABLE
VALUES(1, 'USER01','PASS01','HAN','F');
INSERT INTO USER_PK_TABLE
VALUES(2, 'USER02','PASS02','KIN','F');
INSERT INTO USER_PK_TABLE
VALUES(1, 'USER03','PASS03','CHOI','F');
INSERT INTO USER_PK_TABLE
VALUES(NULL, 'USER03','PASS03','CHOI','F');
--기본키 제약조건을 설정하면 NOTNULL 과 UNIQUE 가 함께 설정된다.

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'USER_PK_TABLE';

--기본키 제약조건을 여러 컬럼에 적용하기
CREATE TABLE USER_PK_TABLE2(
	USER_NO NUMBER(10),
	USER_ID VARCHAR2(20) UNIQUE,
	USER_PWD VARCHAR2(30) NOT NULL,
	USER_NAME VARCHAR2(15) NOT NULL,
	GENDER VARCHAR2(3) CHECK(GENDER IN ('M','F')),
	CONSTRAINT PK_USER_NO2 PRIMARY KEY(USER_NO, USER_ID)
);

INSERT INTO USER_PK_TABLE2 
VALUES(1, 'USER01','PASS01','HAN','F');
INSERT INTO USER_PK_TABLE2 
VALUES(2, 'USER01','PASS01','HAN','F');

--DROP : 객체를 삭제하는 명령어
DROP TABLE MEMBER;

SELECT * FROM MEMBER;

COMMIT;

CREATE TABLE MEMBER(
	MEMBER_NO NUMBER PRIMARY KEY,
	MEMBER_ID VARCHAR2(20) UNIQUE NOT NULL,
	MEMBER_PWD VARCHAR2(20) NOT NULL,
	MEMBER_NAME VARCHAR2(15),
	GENDER CHAR(3) CHECK(GENDER IN ('M','F')),
	MEMBER_EMAIL VARCHAR2(30),
	PHONE VARCHAR2(14),
	MEMBER_BIR DATE
);

COMMENT ON COLUMN MEMBER.MEMBER_NO IS '회원번호';
COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원 아이디';
COMMENT ON COLUMN MEMBER.MEMBER_PWD IS '회원 비밀번호';
COMMENT ON COLUMN MEMBER.MEMBER_NAME IS '이름';

INSERT INTO MEMBER
VALUES(1, 'USER01','PASS01','한예인','F','gore@naver.com','010-1111-1111',TO_DATE(101010,'RRMMDD'));
INSERT INTO MEMBER
VALUES(2, 'USER02','PASS01','둘예인','F','gore8637@naver.com' ,'010-2222-2222',TO_DATE(971113,'RRMMDD'));
INSERT INTO MEMBER
VALUES(3, 'USER03','PASS01',NULL,'F',NULL,'010-3333-3333','1997-11-13');
INSERT INTO MEMBER
VALUES(4, 'USER04','PASS01','넷예인','F',NULL,'010-1111-1111',NULL);
INSERT INTO MEMBER
VALUES(5, 'USER05','PASS01','오예인','F',NULL,'010-1111-1111',NULL);

SELECT * FROM MEMBER;
