---------200522
--FOREIGN KEY
--외래키, 외부키, 참조키라고 한다.
--다른 테이블의 컬럼값을 참조(REFERENCE)하여 참조하는 테이블의 값만 하용
--FOREIGN KEY 제약조건을 통해 다른 테이블과의 관계(RELATIONSHIP)가 형성된다.

--컬럼레벨일 경우
--컬럼명  자료형 (길이)	[CONSTRAINT 제약조건명]	 REFERENCES 참조할 테이블명(참조할 컬럼명)	[삭제옵션]
--테이블 레벨 일 경우
--[CONSTRAINT 제약조건명] FOREIGN KEY(적용할 컬럼명) REFERENCES 참조할 테이블명[(참조할 컬럼명)] [삭제옵션]

DROP TABLE USER_GRADE;

CREATE TABLE USER_GRADE(
	GRADE_CODE NUMBER PRIMARY KEY,
	GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE VALUES(1,'일반 회원');
INSERT INTO USER_GRADE VALUES(2,'VIP');
INSERT INTO USER_GRADE VALUES(3,'VVIP');
INSERT INTO USER_GRADE VALUES(4,'VVVIP');

SELECT * FROM USER_GRADE;

CREATE TABLE USER_FOREIGH_KEY(
	USER_NO NUMBER PRIMARY KEY,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(20),
	USER_NAME VARCHAR2(15),
	GENDER CHAR(1) CHECK(GENDER IN('M','F')),
	GRADE_CODE NUMBER,
	CONSTRAINT FK_GRADE_CODE FOREIGN KEY(GRADE_CODE) REFERENCES USER_GRADE(GRADE_CODE)
);
INSERT INTO USER_FOREIGH_KEY VALUES(1,'123','321','HAN','F',2);
INSERT INTO USER_FOREIGH_KEY VALUES(2,'ABC','123','HAN2','F',4);
INSERT INTO USER_FOREIGH_KEY VALUES(3,'456','456','CHOI','M',1);
INSERT INTO USER_FOREIGH_KEY VALUES(4,'DEF','123','HONG','F',3);
INSERT INTO USER_FOREIGH_KEY VALUES(5,'QWE','123','PARK','M',1);

SELECT * FROM USER_FOREIGH_KEY;
INSERT INTO USER_FOREIGH_KEY VALUES(6,'QWE','123','JANG','M',10);

SELECT *
FROM USER_FOREIGH_KEY 
JOIN USER_GRADE USING(GRADE_CODE);

--삭제옵션
DELET FROM USER_GRADE WHERE GRADE_CODE = 4;

--참조하고 있는 원본 테이블의 컬럼 값이 삭제될때
--참조한 값을 어떻게 처리할 것인지 설정하는 옵션
--1.부모 컬럼의 삭제할 때 자식을 NULL로 변경하기
--ON DELETE SET NULL
--2. 부모컬럼을 삭제할 때 관련된 자식도 함께 삭제하기
--ON DELETE CASCADE
DROP TABLE USER_GRADE;
DROP TABLE USER_FOREIGH_KEY;

CREATE TABLE USER_GRADE(
	GRADE_CODE NUMBER PRIMARY KEY,
	GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE VALUES(1,'일반 회원');
INSERT INTO USER_GRADE VALUES(2,'VIP');
INSERT INTO USER_GRADE VALUES(3,'VVIP');
INSERT INTO USER_GRADE VALUES(4,'VVVIP');

SELECT * FROM USER_GRADE;

--연습1. USER_FOREIGN_KEY + ON DELETE SET NULL
CREATE TABLE USER_FOREIGN_KEY(
	USER_NO NUMBER PRIMARY KEY,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(20),
	USER_NAME VARCHAR2(15),
	GENDER CHAR(1) CHECK(GENDER IN('M','F')),
	GRADE_CODE NUMBER,
	CONSTRAINT FK_GRADE_CODE FOREIGN KEY(GRADE_CODE) 
	REFERENCES USER_GRADE(GRADE_CODE) ON DELETE SET NULL
);

INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','HAN','F',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'ABC','123','HAN2','F',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','456','CHOI','M',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'DEF','123','HONG','F',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'QWE','123','PARK','M',1);

COMMIT;
SELECT * FROM USER_FOREIGN_KEY;

DELETE FROM USER_GRADE WHERE GRADE_CODE = 4;

SELECT * FROM USER_FOREIGN_KEY;
SELECT * FROM USER_GRADE;

ROLLBACK;

--연습2. USER_FOREIGN_KEY + ON DELETE CASCADE
--자식테이블의 데이터 삭제된다.
DROP TABLE USER_FOREIGN_KEY;

CREATE TABLE USER_FOREIGN_KEY(
	USER_NO NUMBER PRIMARY KEY,
	USER_ID VARCHAR2(20),
	USER_PWD VARCHAR2(20),
	USER_NAME VARCHAR2(15),
	GENDER CHAR(1) CHECK(GENDER IN('M','F')),
	GRADE_CODE NUMBER,
	CONSTRAINT FK_GRADE_CODE FOREIGN KEY(GRADE_CODE) 
	REFERENCES USER_GRADE(GRADE_CODE) ON DELETE CASCADE
);

INSERT INTO USER_FOREIGN_KEY VALUES(1,'123','321','HAN','F',2);
INSERT INTO USER_FOREIGN_KEY VALUES(2,'ABC','123','HAN2','F',4);
INSERT INTO USER_FOREIGN_KEY VALUES(3,'456','456','CHOI','M',1);
INSERT INTO USER_FOREIGN_KEY VALUES(4,'DEF','123','HONG','F',3);
INSERT INTO USER_FOREIGN_KEY VALUES(5,'QWE','123','PARK','M',1);

SELECT * FROM USER_FOREIGN_KEY;
SELECT * FROM USER_GRADE;

COMMIT;
DELETE FROM USER_GRADE WHERE GRADE_CODE =2;

ROLLBACK;

--SUBQUERY를 활용한 테이블 생성
--컬럼명, 데이터 타입, 값, NOT NULL 은 복사된다. 하지만 다른 제약조건은 복사되지 않는다.

SELECT * FROM EMPLOYEE;

CREATE TABLE EMPLOYEE_COPY
AS SELECT * FROM EMPLOYEE;

SELECT * FROM EMPLOYEE_COPY;

--테이블 형식만 복사하기
CREATE TABLE EMPLOYEE_COPY2
AS SELECT * FROM EMPLOYEE WHERE 1=2;

SELECT * FROM EMPLOYEE_COPY2;

--각 컬럼에 값을 기록하지 않을 경우 기본값 설정하기
CREATE TABLE DEFAULT_TABLE(
	DATA_COL1 VARCHAR2(30) DEFAULT '없음',
	DATA_COL2 DATE DEFAULT SYSDATE
);

INSERT INTO DEFAULT_TABLE VALUES(DEFAULT, DEFAULT);

SELECT * FROM DEFAULT_TABLE;

--제약조건을 테이블 생성 후에 추가하는 DDL
--ALTER 사용하기
SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMPLOYEE';

--[사용형식]
--ALTER TABLE 테이블명 ADD PRIMARY KEY(컬럼명)
--ALTER TABLE 테이블명 ADD FOREIGN KEY(컬럼명) REFERENCES 테이블명(컬럼명)
--ALTER TABLE 테이블명 ADD UNIQUE(컬럼명) 
--ALTER TABLE 테이블명 ADD CHECK(조건식)
--ALTER TABLE 테이블명 MODIFY 컬럼명 NOT NULL

--문제
--EMPLOYEE 테이블
--DEPT_CODE에 외래키 제약조건 추가
--참조할 컬럼은 DEPARTMENT.DEPT_ID
--JOB_CODE에 외래키 제약 조건 추가
--참조할 컬럼은 JOB.JOB_CODE
--SAL_LEVEL에 외래키 제약 조건 추가
--참조할 컬럼은 SAL_GRADE.SAL_LEVEL
--ENT_YN 컬럼에 CHECK 제약조건 추가('ㅛ','N) 대소문자 구분
--SALARY 컬럼에 CHECK 제약조건 추가 (무조건 양수 기입)
--EMP_NO 컬럼에 UNIQUE 제약조건 추가
--DEPARTMENT 테이블에서
--LOCATION_ID에 외래키 제약조건 추가
--LOCATION테이블 기본키 컬럼
--LOCATION 테이블에서 NATIONAL_CODE 외래키 제약조건 추가
--NATIONAL 테이블의 기본키 컬럼

ALTER TABLE EMPLOYEE ADD FOREIGN KEY(DEPT_CODE) REFERENCES DEPARTMENT(DEPT_ID);
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(JOB_CODE) REFERENCES JOB(JOB_CODE);
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(SAL_LEVEL) REFERENCES SAL_GRADE(SAL_LEVEL);
ALTER TABLE EMPLOYEE ADD CHECK(ENT_YN IN('Y','N'));
ALTER TABLE EMPLOYEE ADD CHECK(SALARY > 0);
ALTER TABLE EMPLOYEE ADD UNIQUE(EMP_NO)
ALTER TABLE DEPARTMENT ADD FOREIGN KEY(LOCATION_ID) REFERENCES LOCATION;
ALTER TABLE LOCATION ADD FOREIGN KEY(NATIONAL_CODE) REFERENCES NATIONAL;

SELECT C1.TABLE_NAME, C1.CONSTRAINT_NAME, CONSTRAINT_TYPE, COLUMN_NAME, SEARCH_CONDITION
FROM USER_CONSTRAINTS C1
JOIN USER_CONS_COLUMNS C2 ON(C1.TABLE_NAME = C2.TABLE_NAME 
							AND C1.CONSTRAINT_NAME = C2.CONSTRAINT_NAME)
WHERE C1.TABLE_NAME IN('EMPLOYEE','DEPARTMENT','LOCATION');


--DML(데이터 조작언어)
--INSERT, UPDATE, DELETE, SELECT(DQL)
--[CRUD]
--C(CREATE) :INSERT
--R(READ) : SELECT
--U(UPDATE) : UPDATE
--D(DELETE) : DELETE

--INSERT: 새로운 행을 특정 테이블에 추가하는 명령어 , 실행후에는 테이블의 행의 개수가 증가
-- 1.특정 컬럼에 값을 추가하는 방법
-- INSERT INTO 테이블명 (컬럼명, . . . . ) VALUES(값, ...);
--INSERT INTO 테이블명 VALUES(값, 값, ....);

SELECT * FROM EMPLOYEE;
--컬럼명을 명시하여 데이터 추가
INSERT INTO EMPLOYEE(EMP_ID, EMP_NAME, EMP_NO, EMAIL, PHONE, DEPT_CODE, JOB_CODE,
	SAL_LEVEL, SALARY, BONUS, MANAGER_ID, HIRE_DATE, ENT_DATE, ENT_YN)
VALUES(500, '한예인','971113-1234567','han@naver.com','01011111111', 'D1','J7',
		'S4',3100000,0.1,'200',SYSDATE, NULL, DEFAULT);

SELECT * FROM EMPLOYEE WHERE EMP_NAME = '한예인';

--컬럼을 생각하고 사용하기(모든 컬럼에 추가)	
INSERT INTO EMPLOYEE
VALUES(900,'둘예인','971212-1234567','han2naveer.com','0102223333','D1','J7','S3', 43000000,
	0.2,'200',SYSDATE, NULL,DEFAULT	);
SELECT * FROM EMPLOYEE;

COMMIT;
--INSERT + SUBQUERY
--VALUES 대신 값을 지정하여 추가 기능
CREATE TABLE EMP_01(
	EMP_ID NUMBER,
	EMP_NAME VARCHAR2(20),
	DEPT_TITLE VARCHAR2(40)
);
INSERT INTO EMP_01 (
	SELECT EMP_ID, EMP_NAME, DEPT_TITLE
	FROM EMPLOYEE 
	LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
);
SELECT * FROM EMP_01;


--
CREATE TABLE EMP_DEPT_D1
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
FROM EMPLOYEE
WHERE 1=2;
--EMPLOYEE 테이블에서 D1부서에 근무하는 직원들의
--사번, 이름, 부서코드, 입사일을 조회하여
--EMP_DEPT_D1 테이블에 추가
INSERT INTO EMP_DEPT_D1(
	SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
	FROM EMPLOYEE
	WHERE DEPT_CODE = 'D1'
);
SELECT * FROM EMP_DEPT_D1;

COMMIT;

CREATE TABLE EMP_OLD
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
FROM EMPLOYEE 
WHERE 1=2;

CREATE TABLE EMP_NEW
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
FROM EMPLOYEE 
WHERE 1=2;

--EMPLOYEE 입시일 기준 2000년 1월 1일 이전 입사자의 사번, 이름 입사일 급여를 EMP_OLD에 추가하고
--그 이후에 입사자들의 사번, 이름 입사일 급여를 EMP_NEW에 추가하여 처리

INSERT ALL
	WHEN HIRE_DATE < '2000/01/01'
	THEN INTO EMP_OLD VALUES(EMP_ID, EMP_NAME, HIRE_DATE,SALARY)
	WHEN HIRE_DATE >= '2000/01/01'
	THEN INTO EMP_NEW VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)
	SELECT * FROM EMPLOYEE;

SELECT * FROM EMP_OLD;
SELECT * FROM EMP_NEW;

COMMIT;

--UPDATE : 해당 테이블의 데이터를 수정하는 명령어
--[사용형식]
--UPDATE 테이블명 SET 컬럼명 = 변경할 값
--[WHERE 컬럼명 비교연산자 비교값]

CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY;

--D9부서를 총무부 -> 전략기회부

COMMIT;
UPDATE DEPT_COPY 
SET DEPT_TITLE = '전략기획부';
ROLLBACK;

UPDATE DEPT_COPY
SET DEPT_TITLE = '전략기획부'
WHERE DEPT_ID = 'D9';

SELECT * FROM DEPT_COPY;

COMMIT;

--EMPLOYEE 테이블에서 사번이 200,201,214인 사원의 주민등록번호 앞자리를
-- 각각 621130, 630126, 850507로 수정
SELECT * FROM EMPLOYEE;

UPDATE EMPLOYEE 
SET EMP_NO ='621130' || SUBSTR(EMP_NO,7) 
WHERE EMP_ID = 200;

UPDATE EMPLOYEE 
SET EMP_NO ='630126' || SUBSTR(EMP_NO,7) 
WHERE EMP_ID = 201;

UPDATE EMPLOYEE 
SET EMP_NO ='850507' || SUBSTR(EMP_NO,7) 
WHERE EMP_ID = 214;

--UPDATE+SUBQUERY
--여러행을 변경하거나, 여러 컬럼의 값을 변경하고자 할 때 서브 쿼리를 사용하여 UPDATE를 작성 할 수 있다.
--UPDATE 테이블 SET 컬럼명 (서브쿼리);
CREATE TABLE EMP_SALARY
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY, BONUS
FROM EMPLOYEE;

SELECT * FROM EMP_SALARY 
WHERE EMP_NAME IN('유재식','방명수');

--유재식 사원과 같은 급여와 보너스를 받고 싶어하는 방명수 사원의 급여와 보너스를 유지식 사원과 같은 값으로 변경하는 쿼리 작성
--단일 행 서브쿼리 활용
UPDATE EMP_SALARY 
SET SALARY  = (SELECT SALARY FROM EMP_SALARY WHERE EMP_NAME='유재식'),
	BONUS = (SELECT BONUS FROM EMP_SALARY WHERE EMP_NAME = '유재식')
WHERE EMP_NAME = '방명수'	;

--'노옹철' '전형돈' '정중하' '하동운' 의 유재식과 같은 급여, 보너스로 수정
UPDATE EMP_SALARY 
SET (SALARY, BONUS) = (SELECT SALARY, BONUS FROM EMP_SALARY WHERE EMP_NAME = '유재식')
WHERE EMP_NAME IN('노옹철','정중하','전형돈','하동운');

SELECT * FROM EMP_SALARY 
WHERE EMP_NAME IN('노옹철','정중하','전형돈','하동운');

--UPDATE 변경할 값이 제약조건에 위배되지 않아야 한다.

UPDATE EMPLOYEE 
SET DEPT_CODE = 'D0'
WHERE DEPT_CODE = 'D6';

--NOT NULL 제약조건 위배
UPDATE EMPLOYEE 
SET EMP_ID = NULL;
WHERE EMP_ID = 200;

SELECT * FROM EMPLOYEE;

UPDATE EMPLOYEE 
SET EMP_NO ='630126-1548654'
WHERE EMP_NAME = '선동일';

SELECT * FROM EMPLOYEE 
WHERE EMP_ID = 222;

--UPDATE시 DEFAULT 활용
UPDATE EMPLOYEE 
SET ENT_YN = DEFAULT
WHERE EMP_ID = 222;
